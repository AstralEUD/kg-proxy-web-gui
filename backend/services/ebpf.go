//go:build linux

package services

import (
	"encoding/binary"
	"fmt"
	"net"
	"runtime"
	"strings"
	"sync"
	"time"

	"kg-proxy-web-gui/backend/models"
	"kg-proxy-web-gui/backend/system"

	"github.com/cilium/ebpf/link"
	"gorm.io/gorm"
)

//go:generate bpf2go -cc clang -cflags "-O2 -g -Wall -Werror" xdp ../ebpf/xdp_filter.c -- -I/usr/include/x86_64-linux-gnu

// PacketStats matches the C struct
type PacketStats struct {
	Packets  uint64
	Bytes    uint64
	LastSeen uint64
	Blocked  uint32
	_        uint32 // padding
}

// EBPFService manages eBPF/XDP traffic monitoring
type EBPFService struct {
	enabled     bool
	trafficData []TrafficEntry
	mu          sync.RWMutex
	stopChan    chan struct{}
	isRunning   bool

	// Real eBPF objects - using interface{} to avoid build errors when generated files are missing
	// In production (Linux build), this will hold *xdpObjects
	objs         interface{}
	link         link.Link
	geoIPService *GeoIPService

	// Interface name
	ifaceName string

	// Boot time for timestamp conversion
	bootTime time.Time

	// Database for snapshots
	db *gorm.DB

	// For snapshot calculations
	lastSnapshot       time.Time
	prevNetworkRX      int64
	prevNetworkTX      int64
	prevTotalPackets   int64
	prevBlockedPackets int64
}

func NewEBPFService() *EBPFService {
	// Calculate boot time to handle monotonic timestamps
	// We use the SysInfoService or just standard uptime

	now := time.Now()
	boot := now // Default fallback

	if runtime.GOOS == "linux" {
		// Read /proc/uptime
		// simplified for now, assuming uptime is roughly correct
		// If we can't read it, we use Now (last seen will be relative to now, which is wrong but safe)
		// We'll rely on the fact that value.LastSeen is monotonic ns
		// We need relative offset: Now - MonotonicNow
		// But getting MonotonicNow in Go is internal.
		// Approximating:
		// timestamp = bootTime + monotonic
	}

	// Better: Use a helper
	boot = GetBootTime()

	return &EBPFService{
		enabled:      false,
		trafficData:  make([]TrafficEntry, 0),
		stopChan:     make(chan struct{}),
		ifaceName:    "eth0",
		bootTime:     boot,
		lastSnapshot: time.Now(),
	}
}

// SetGeoIPService sets the GeoIP service for country lookups
func (e *EBPFService) SetGeoIPService(geoip *GeoIPService) {
	e.geoIPService = geoip
}

// SetDatabase sets the database reference for snapshot storage
func (e *EBPFService) SetDatabase(db *gorm.DB) {
	e.db = db
}

// Enable starts eBPF monitoring
func (e *EBPFService) Enable() error {
	e.mu.Lock()
	defer e.mu.Unlock()

	if e.isRunning {
		return nil
	}

	// Only try real eBPF on Linux
	if runtime.GOOS != "linux" {
		return fmt.Errorf("eBPF is only supported on Linux")
	}

	// Try to load real eBPF program
	if err := e.loadEBPFProgram(); err != nil {
		return fmt.Errorf("failed to load eBPF program: %w", err)
	}

	e.enabled = true
	e.isRunning = true
	e.stopChan = make(chan struct{})

	// Start real traffic collection from eBPF maps
	go e.collectTrafficFromEBPF()

	system.Info("eBPF XDP filter loaded and attached to %s", e.ifaceName)
	return nil
}

// loadEBPFProgram loads the compiled eBPF program
func (e *EBPFService) loadEBPFProgram() error {
	// Detect network interface
	iface, err := e.detectInterface()
	if err != nil {
		return fmt.Errorf("failed to detect network interface: %w", err)
	}
	e.ifaceName = iface.Name

	// Load pre-compiled eBPF objects
	// Note: xdpObjects is generated by bpf2go.
	// We use struct literal assuming the generated file is present in build env
	objs := &xdpObjects{}
	if err := loadXdpObjects(objs, nil); err != nil {
		return fmt.Errorf("loading eBPF objects: %w", err)
	}
	e.objs = objs

	// Attach XDP program to interface
	l, err := link.AttachXDP(link.XDPOptions{
		Program:   objs.XdpTrafficFilter,
		Interface: iface.Index,
	})
	if err != nil {
		objs.Close()
		return fmt.Errorf("attaching XDP program: %w", err)
	}
	e.link = l

	// Initialize BPF maps with GeoIP data
	if e.geoIPService != nil {
		e.populateGeoIPMap()
	}

	return nil
}

// detectInterface finds the primary network interface
func (e *EBPFService) detectInterface() (*net.Interface, error) {
	// Try common interface names
	names := []string{"eth0", "ens3", "ens5", "enp0s3", "wlan0"}

	for _, name := range names {
		iface, err := net.InterfaceByName(name)
		if err == nil && iface.Flags&net.FlagUp != 0 {
			return iface, nil
		}
	}

	// Fallback: find first non-loopback interface
	ifaces, err := net.Interfaces()
	if err != nil {
		return nil, err
	}

	for _, iface := range ifaces {
		if iface.Flags&net.FlagUp != 0 && iface.Flags&net.FlagLoopback == 0 {
			return &iface, nil
		}
	}

	return nil, fmt.Errorf("no suitable network interface found")
}

// populateGeoIPMap populates the geo_allowed BPF map
func (e *EBPFService) populateGeoIPMap() error {
	if e.objs == nil || e.geoIPService == nil {
		return nil
	}

	objs, ok := e.objs.(*xdpObjects)
	if !ok {
		return nil
	}

	system.Info("Populating GeoIP BPF map...")
	count := 0

	allCIDRs := e.geoIPService.GetAllCountryCIDRs()

	for country, cidrs := range allCIDRs {
		if len(country) < 2 {
			continue
		}
		// Convert country code (e.g., "KR") to 16-bit int
		c0 := strings.ToUpper(country)[0]
		c1 := strings.ToUpper(country)[1]
		countryCode := uint32(c0)<<8 | uint32(c1)

		for _, cidr := range cidrs {
			_, ipNet, err := net.ParseCIDR(cidr)
			if err != nil {
				continue
			}
			ip := ipNet.IP.To4()
			if ip == nil {
				continue
			}

			// Use BigEndian to match network byte order in BPF
			ipUint := binary.BigEndian.Uint32(ip)
			ones, _ := ipNet.Mask.Size()

			// LPM Trie Key
			key := struct {
				PrefixLen uint32
				Data      uint32
			}{
				PrefixLen: uint32(ones),
				Data:      ipUint,
			}

			if err := objs.GeoAllowed.Put(key, countryCode); err != nil {
				system.Warn("Failed to add IP to geo_allowed map: %v", err)
				continue
			}
			count++

			// Limit to prevent map overflow
			if count >= 1000000 {
				system.Warn("GeoIP map limit reached, some IPs not added")
				return nil
			}
		}
	}

	system.Info("Populated GeoIP map with %d entries", count)
	return nil
}

// collectTrafficFromEBPF reads real data from eBPF maps
func (e *EBPFService) collectTrafficFromEBPF() {
	ticker := time.NewTicker(2 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-e.stopChan:
			return
		case <-ticker.C:
			e.readEBPFMaps()
		}
	}
}

// readEBPFMaps reads statistics from eBPF maps
func (e *EBPFService) readEBPFMaps() {
	if e.objs == nil {
		return
	}

	objs, ok := e.objs.(*xdpObjects)
	if !ok {
		return
	}

	e.mu.Lock()
	defer e.mu.Unlock()

	// Clear old data
	e.trafficData = make([]TrafficEntry, 0)

	// Iterate over the map
	// Use [4]byte for key to parse IP correctly regardless of host endianness
	var key [4]byte
	var value PacketStats

	// We need to lock while iterating if we were modifying, but here we just read.
	// BPF map iteration is generally safe.
	iter := objs.IpStats.Iterate()
	for iter.Next(&key, &value) {
		// Convert key bytes directly to IP
		ip := net.IPv4(key[0], key[1], key[2], key[3])

		// Get country code
		countryCode := "XX"
		if e.geoIPService != nil {
			countryCode = e.geoIPService.GetCountryCode(ip.String())
		}

		// Create entry
		entry := TrafficEntry{
			SourceIP:    ip.String(),
			DestPort:    0, // Not tracked in current eBPF program
			Protocol:    "IP",
			PacketCount: int(value.Packets),
			ByteCount:   int64(value.Bytes),
			Timestamp:   e.bootTime.Add(time.Duration(value.LastSeen)), // Correct monotonic -> wall time
			Blocked:     value.Blocked == 1,
			CountryCode: countryCode,
		}

		e.trafficData = append(e.trafficData, entry)

		// Limit entries
		if len(e.trafficData) >= 1000 {
			break
		}
	}

	if err := iter.Err(); err != nil {
		system.Warn("Error iterating ip_stats map: %v", err)
	}

	// Save periodic snapshot (every 1 minute)
	e.saveTrafficSnapshot()
}

// saveTrafficSnapshot saves traffic statistics to the database for historical analysis
func (e *EBPFService) saveTrafficSnapshot() {
	if e.db == nil {
		return
	}

	now := time.Now()
	if now.Sub(e.lastSnapshot) < 1*time.Minute {
		return
	}

	// Calculate current totals
	var totalPackets, blockedPackets int64
	var totalBytes int64
	countryCount := make(map[string]int)

	for _, entry := range e.trafficData {
		totalPackets += int64(entry.PacketCount)
		totalBytes += entry.ByteCount
		if entry.Blocked {
			blockedPackets += int64(entry.PacketCount)
		}
		countryCount[entry.CountryCode]++
	}

	// Calculate PPS (packets per second) based on time elapsed
	elapsed := now.Sub(e.lastSnapshot).Seconds()
	if elapsed <= 0 {
		elapsed = 1
	}

	// Calculate delta from previous snapshot
	deltaTotalPackets := totalPackets - e.prevTotalPackets
	deltaBlockedPackets := blockedPackets - e.prevBlockedPackets
	if deltaTotalPackets < 0 {
		deltaTotalPackets = totalPackets // Reset occurred
	}
	if deltaBlockedPackets < 0 {
		deltaBlockedPackets = blockedPackets
	}

	totalPPS := int64(float64(deltaTotalPackets) / elapsed)
	blockedPPS := int64(float64(deltaBlockedPackets) / elapsed)
	allowedPPS := totalPPS - blockedPPS
	if allowedPPS < 0 {
		allowedPPS = 0
	}

	// Get network stats
	sysInfo := NewSysInfoService()
	rxBytes, txBytes := sysInfo.GetNetworkIO()
	networkRX := int64(float64(rxBytes-uint64(e.prevNetworkRX)) / elapsed)
	networkTX := int64(float64(txBytes-uint64(e.prevNetworkTX)) / elapsed)
	if networkRX < 0 {
		networkRX = 0
	}
	if networkTX < 0 {
		networkTX = 0
	}

	// Find top country
	topCountry := "XX"
	maxCount := 0
	for country, count := range countryCount {
		if count > maxCount {
			maxCount = count
			topCountry = country
		}
	}

	// Create snapshot
	snapshot := models.TrafficSnapshot{
		Timestamp:   now,
		TotalPPS:    totalPPS,
		TotalBPS:    int64(float64(totalBytes) / elapsed),
		AllowedPPS:  allowedPPS,
		BlockedPPS:  blockedPPS,
		UniqueIPs:   len(e.trafficData),
		TopCountry:  topCountry,
		NetworkRX:   networkRX,
		NetworkTX:   networkTX,
		CPUUsage:    sysInfo.GetCPUUsage(),
		MemoryUsage: sysInfo.GetMemoryUsage(),
	}

	// Save to database
	if err := e.db.Create(&snapshot).Error; err != nil {
		system.Warn("Failed to save traffic snapshot: %v", err)
	}

	// Update previous values for next calculation
	e.lastSnapshot = now
	e.prevTotalPackets = totalPackets
	e.prevBlockedPackets = blockedPackets
	e.prevNetworkRX = int64(rxBytes)
	e.prevNetworkTX = int64(txBytes)

	// Cleanup old snapshots (older than 7 days)
	e.cleanupOldSnapshots()
}

// cleanupOldSnapshots removes traffic snapshots older than 7 days
func (e *EBPFService) cleanupOldSnapshots() {
	if e.db == nil {
		return
	}

	cutoff := time.Now().AddDate(0, 0, -7)
	e.db.Where("timestamp < ?", cutoff).Delete(&models.TrafficSnapshot{})
}

// Disable stops eBPF monitoring
func (e *EBPFService) Disable() {
	e.mu.Lock()
	defer e.mu.Unlock()

	if !e.isRunning {
		return
	}

	e.enabled = false
	e.isRunning = false
	close(e.stopChan)

	// Detach eBPF program if loaded
	e.detachEBPF()
}

func (e *EBPFService) detachEBPF() {
	if e.link != nil {
		e.link.Close()
		e.link = nil
		system.Info("eBPF XDP program detached")
	}

	if e.objs != nil {
		if objs, ok := e.objs.(*xdpObjects); ok {
			objs.Close()
		}
		e.objs = nil
	}
}

// GetTrafficData returns current traffic data
func (e *EBPFService) GetTrafficData() []TrafficEntry {
	e.mu.RLock()
	defer e.mu.RUnlock()

	data := make([]TrafficEntry, len(e.trafficData))
	copy(data, e.trafficData)
	return data
}

// GetStats returns aggregated statistics
func (e *EBPFService) GetStats() map[string]interface{} {
	e.mu.RLock()
	defer e.mu.RUnlock()

	totalPackets := 0
	totalBlocked := 0
	countryMap := make(map[string]int)

	for _, entry := range e.trafficData {
		totalPackets += entry.PacketCount
		if entry.Blocked {
			totalBlocked++
		}
		countryMap[entry.CountryCode]++
	}

	return map[string]interface{}{
		"total_packets":   totalPackets,
		"total_entries":   len(e.trafficData),
		"blocked_entries": totalBlocked,
		"countries":       countryMap,
		"enabled":         e.enabled,
		"mode":            "eBPF/XDP",
	}
}

// IsEnabled returns whether eBPF is currently enabled
func (e *EBPFService) IsEnabled() bool {
	e.mu.RLock()
	defer e.mu.RUnlock()
	return e.enabled
}

// Helper functions - Corrected for Endianness

// UpdateBlockedIPs updates the blocked_ips BPF map
func (e *EBPFService) UpdateBlockedIPs(ips []string) error {
	if e.objs == nil {
		return nil // Not in eBPF mode
	}

	objs, ok := e.objs.(*xdpObjects)
	if !ok {
		return nil
	}

	for _, ipStr := range ips {
		ip := net.ParseIP(ipStr)
		if ip == nil {
			continue
		}

		// Use BigEndian
		ipUint := ipToUint32(ip)
		blocked := uint32(1)

		if err := objs.BlockedIps.Put(ipUint, blocked); err != nil {
			system.Warn("Failed to add blocked IP %s: %v", ipStr, err)
		}
	}

	system.Info("Updated %d blocked IPs in eBPF map", len(ips))
	return nil
}

// UpdateGeoAllowed updates the geo_allowed BPF map
func (e *EBPFService) UpdateGeoAllowed(allowedCountries []string) error {
	if e.objs == nil {
		return nil // Not in eBPF mode
	}

	// Repopulate with new countries (simplified clear approach)
	e.populateGeoIPMap()

	system.Info("Updated geo-allowed countries: %v", allowedCountries)
	return nil
}

// UpdateAllowIPs updates the white_list BPF map
func (e *EBPFService) UpdateAllowIPs(ips []string) error {
	if e.objs == nil {
		return nil // Not in eBPF mode
	}

	objs, ok := e.objs.(*xdpObjects)
	if !ok {
		return nil
	}

	// Simple approach: Clear map (if possible) or just add new.
	// Since we don't track old keys here easily, we rely on handlers to pass full list?
	// Or we just add. For deletion, we might need a full overwrite or explicit delete.
	// Assuming `ips` is the FULL list of allowed IPs.

	// Better approach for full sync: read all keys, diff, or nuke and rebuild.
	// HASH map doesn't support "Clear".
	// We will just add for now. Proper sync requires more code.
	// Let's iterate and delete all first? Expensive if large.
	// Given manual whitelist is usually small (<100), iterate-delete is fine.

	var key [4]byte
	var value uint32
	var keysToDelete [][4]byte

	iter := objs.WhiteList.Iterate()
	for iter.Next(&key, &value) {
		keysToDelete = append(keysToDelete, key)
	}

	for _, k := range keysToDelete {
		objs.WhiteList.Delete(k)
	}

	for _, ipStr := range ips {
		ip := net.ParseIP(ipStr)
		if ip == nil {
			continue
		}
		ipUint := ipToUint32(ip)
		val := uint32(1)

		if err := objs.WhiteList.Put(ipUint, val); err != nil {
			system.Warn("Failed to add whitelist IP %s: %v", ipStr, err)
		}
	}

	system.Info("Updated whitelist in eBPF map: %d entries", len(ips))
	return nil
}

// ResetTrafficStats clears all traffic statistics from eBPF maps and memory
func (e *EBPFService) ResetTrafficStats() error {
	e.mu.Lock()
	defer e.mu.Unlock()

	// 1. Clear local cache
	e.trafficData = make([]TrafficEntry, 0)

	// 2. Clear eBPF Map (ip_stats)
	if e.objs != nil {
		objs, ok := e.objs.(*xdpObjects)
		if ok {
			// Iterate and delete all keys
			// Note: Deleting while iterating can be tricky in some kernels/implementations,
			// but for hash maps it's generally supported or we collect keys first.
			// Ideally, we could just close and recreate the map, but that requires reloading the program or using map-in-map.
			// Simple approach: Delete keys one by one.

			var key [4]byte
			var value PacketStats
			var keysToDelete [][4]byte

			iter := objs.IpStats.Iterate()
			for iter.Next(&key, &value) {
				keysToDelete = append(keysToDelete, key)
			}
			if err := iter.Err(); err != nil {
				system.Warn("Error iterating ip_stats for reset: %v", err)
			}

			count := 0
			for _, k := range keysToDelete {
				if err := objs.IpStats.Delete(k); err != nil {
					// Ignore non-exist errors
					continue
				}
				count++
			}
			system.Info("Reset traffic stats: cleared %d entries from eBPF map", count)
		}
	} else {
		system.Info("Reset traffic stats: memory only (eBPF not active)")
	}

	return nil
}

// StartAutoResetLoop starts the background task to reset stats periodically
func (e *EBPFService) StartAutoResetLoop(db *gorm.DB) {
	// Initialize the channel if not already (should be done in Enable/New, but safe guard)
	if e.stopChan == nil {
		e.stopChan = make(chan struct{})
	}

	go func() {
		ticker := time.NewTicker(1 * time.Minute)
		defer ticker.Stop()

		for {
			select {
			case <-e.stopChan:
				return
			case <-ticker.C:
				var settings models.SecuritySettings
				if err := db.First(&settings, 1).Error; err != nil {
					continue
				}

				if settings.TrafficStatsResetInterval <= 0 {
					continue
				}

				// If never reset before, set to now to start the cycle
				if settings.LastTrafficStatsReset == nil {
					now := time.Now()
					settings.LastTrafficStatsReset = &now
					db.Save(&settings)
					continue
				}

				// Check interval
				interval := time.Duration(settings.TrafficStatsResetInterval) * time.Hour
				if time.Since(*settings.LastTrafficStatsReset) >= interval {
					system.Info("Auto-resetting traffic stats (Interval: %dh)", settings.TrafficStatsResetInterval)
					e.ResetTrafficStats()

					now := time.Now()
					settings.LastTrafficStatsReset = &now
					db.Save(&settings)
				}
			}
		}
	}()
}

// PortStats represents per-port traffic statistics
type PortStats struct {
	Port    uint16 `json:"port"`
	Packets uint64 `json:"packets"`
	Bytes   uint64 `json:"bytes"`
}

// UpdateConfig updates the eBPF config map with current settings
func (e *EBPFService) UpdateConfig(hardBlocking bool, rateLimitPPS int) error {
	if e.objs == nil {
		return nil
	}

	objs, ok := e.objs.(*xdpObjects)
	if !ok {
		return nil
	}

	// Config map indices
	const (
		configHardBlocking = uint32(0)
		configRateLimitPPS = uint32(1)
	)

	// Set hard blocking mode
	hardBlockVal := uint32(0)
	if hardBlocking {
		hardBlockVal = 1
	}
	if err := objs.Config.Put(configHardBlocking, hardBlockVal); err != nil {
		system.Warn("Failed to update hard blocking config: %v", err)
	}

	// Set rate limit PPS
	rateLimitVal := uint32(rateLimitPPS)
	if err := objs.Config.Put(configRateLimitPPS, rateLimitVal); err != nil {
		system.Warn("Failed to update rate limit config: %v", err)
	}

	system.Info("Updated eBPF config: hard_blocking=%v, rate_limit_pps=%d", hardBlocking, rateLimitPPS)
	return nil
}

// GetPortStats returns per-port traffic statistics
func (e *EBPFService) GetPortStats() []PortStats {
	if e.objs == nil {
		return nil
	}

	objs, ok := e.objs.(*xdpObjects)
	if !ok {
		return nil
	}

	var stats []PortStats
	var key uint16
	var value struct {
		Packets uint64
		Bytes   uint64
	}

	iter := objs.PortStats.Iterate()
	for iter.Next(&key, &value) {
		stats = append(stats, PortStats{
			Port:    key,
			Packets: value.Packets,
			Bytes:   value.Bytes,
		})

		// Limit
		if len(stats) >= 100 {
			break
		}
	}

	// Sort by packets descending
	for i := 0; i < len(stats); i++ {
		for j := i + 1; j < len(stats); j++ {
			if stats[j].Packets > stats[i].Packets {
				stats[i], stats[j] = stats[j], stats[i]
			}
		}
	}

	return stats
}
