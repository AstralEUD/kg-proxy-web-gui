package services

import (
	"encoding/binary"
	"fmt"
	"net"
	"runtime"
	"sync"
	"time"

	"kg-proxy-web-gui/backend/system"

	"github.com/cilium/ebpf/link"
)

//go:generate bpf2go -cc clang -cflags "-O2 -g -Wall -Werror" xdp ../ebpf/xdp_filter.c -- -I/usr/include/x86_64-linux-gnu

// TrafficEntry represents a single traffic record
type TrafficEntry struct {
	SourceIP    string
	DestPort    int
	Protocol    string
	PacketCount int
	ByteCount   int64
	Timestamp   time.Time
	Blocked     bool
	CountryCode string
}

// PacketStats matches the C struct
type PacketStats struct {
	Packets  uint64
	Bytes    uint64
	LastSeen uint64
	Blocked  uint32
	_        uint32 // padding
}

// EBPFService manages eBPF/XDP traffic monitoring
type EBPFService struct {
	enabled     bool
	trafficData []TrafficEntry
	mu          sync.RWMutex
	stopChan    chan struct{}
	isRunning   bool

	// Real eBPF objects - using interface{} to avoid build errors when generated files are missing
	// In production (Linux build), this will hold *xdpObjects
	objs         interface{}
	link         link.Link
	geoIPService *GeoIPService

	// Interface name
	ifaceName string
}

func NewEBPFService() *EBPFService {
	return &EBPFService{
		enabled:     false,
		trafficData: make([]TrafficEntry, 0),
		stopChan:    make(chan struct{}),
		ifaceName:   "eth0", // Default, will auto-detect
	}
}

// SetGeoIPService sets the GeoIP service for country lookups
func (e *EBPFService) SetGeoIPService(geoip *GeoIPService) {
	e.geoIPService = geoip
}

// Enable starts eBPF monitoring
func (e *EBPFService) Enable() error {
	e.mu.Lock()
	defer e.mu.Unlock()

	if e.isRunning {
		return nil
	}

	// Only try real eBPF on Linux
	if runtime.GOOS != "linux" {
		system.Warn("eBPF only supported on Linux, using simulation mode")
		e.enabled = true
		e.isRunning = true
		e.stopChan = make(chan struct{})
		go e.collectTrafficSimulation()
		return nil
	}

	// Try to load real eBPF program
	if err := e.loadEBPFProgram(); err != nil {
		return fmt.Errorf("failed to load eBPF program: %w", err)
	}

	e.enabled = true
	e.isRunning = true
	e.stopChan = make(chan struct{})

	// Start real traffic collection from eBPF maps
	go e.collectTrafficFromEBPF()

	system.Info("eBPF XDP filter loaded and attached to %s", e.ifaceName)
	return nil
}

// loadEBPFProgram loads the compiled eBPF program
func (e *EBPFService) loadEBPFProgram() error {
	// Detect network interface
	iface, err := e.detectInterface()
	if err != nil {
		return fmt.Errorf("failed to detect network interface: %w", err)
	}
	e.ifaceName = iface.Name

	// Load pre-compiled eBPF objects
	// Note: xdpObjects is generated by bpf2go.
	// We use struct literal assuming the generated file is present in build env
	objs := &xdpObjects{}
	if err := loadxdpObjects(objs, nil); err != nil {
		return fmt.Errorf("loading eBPF objects: %w", err)
	}
	e.objs = objs

	// Attach XDP program to interface
	l, err := link.AttachXDP(link.XDPOptions{
		Program:   objs.XdpTrafficFilter,
		Interface: iface.Index,
	})
	if err != nil {
		objs.Close()
		return fmt.Errorf("attaching XDP program: %w", err)
	}
	e.link = l

	// Initialize BPF maps with GeoIP data
	if e.geoIPService != nil {
		e.populateGeoIPMap()
	}

	return nil
}

// detectInterface finds the primary network interface
func (e *EBPFService) detectInterface() (*net.Interface, error) {
	// Try common interface names
	names := []string{"eth0", "ens3", "ens5", "enp0s3", "wlan0"}

	for _, name := range names {
		iface, err := net.InterfaceByName(name)
		if err == nil && iface.Flags&net.FlagUp != 0 {
			return iface, nil
		}
	}

	// Fallback: find first non-loopback interface
	ifaces, err := net.Interfaces()
	if err != nil {
		return nil, err
	}

	for _, iface := range ifaces {
		if iface.Flags&net.FlagUp != 0 && iface.Flags&net.FlagLoopback == 0 {
			return &iface, nil
		}
	}

	return nil, fmt.Errorf("no suitable network interface found")
}

// populateGeoIPMap populates the geo_allowed BPF map
func (e *EBPFService) populateGeoIPMap() error {
	if e.objs == nil || e.geoIPService == nil {
		return nil
	}

	objs, ok := e.objs.(*xdpObjects)
	if !ok {
		return nil
	}

	system.Info("Populating GeoIP BPF map...")
	count := 0

	e.geoIPService.mu.RLock()
	defer e.geoIPService.mu.RUnlock()

	for country, ranges := range e.geoIPService.countryRanges {
		countryCode := uint32(country[0])<<8 | uint32(country[1])

		for _, ipRange := range ranges {
			// For each IP in the range, add to map
			ip := ipRange.IP.To4()
			if ip == nil {
				continue
			}

			// Use BigEndian to match network byte order in BPF
			ipUint := binary.BigEndian.Uint32(ip)

			if err := objs.GeoAllowed.Put(ipUint, countryCode); err != nil {
				system.Warn("Failed to add IP to geo_allowed map: %v", err)
				continue
			}
			count++

			// Limit to prevent map overflow
			if count >= 100000 {
				system.Warn("GeoIP map limit reached, some IPs not added")
				return nil
			}
		}
	}

	system.Info("Populated GeoIP map with %d entries", count)
	return nil
}

// collectTrafficFromEBPF reads real data from eBPF maps
func (e *EBPFService) collectTrafficFromEBPF() {
	ticker := time.NewTicker(2 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-e.stopChan:
			return
		case <-ticker.C:
			e.readEBPFMaps()
		}
	}
}

// readEBPFMaps reads statistics from eBPF maps
func (e *EBPFService) readEBPFMaps() {
	if e.objs == nil {
		return
	}

	objs, ok := e.objs.(*xdpObjects)
	if !ok {
		return
	}

	e.mu.Lock()
	defer e.mu.Unlock()

	// Clear old data
	e.trafficData = make([]TrafficEntry, 0)

	// Iterate over ip_stats map
	var (
		key   uint32
		value PacketStats
	)

	iter := objs.IpStats.Iterate()
	for iter.Next(&key, &value) {
		// Convert IP (Big Endian to matching IP)
		ip := uint32ToIP(key)

		// Get country code
		countryCode := "XX"
		if e.geoIPService != nil {
			countryCode = e.geoIPService.GetCountryCode(ip.String())
		}

		// Create entry
		entry := TrafficEntry{
			SourceIP:    ip.String(),
			DestPort:    0, // Not tracked in current eBPF program
			Protocol:    "IP",
			PacketCount: int(value.Packets),
			ByteCount:   int64(value.Bytes),
			Timestamp:   time.Unix(0, int64(value.LastSeen)), // Timestamp logic might need adjustment for boot time offset
			Blocked:     value.Blocked == 1,
			CountryCode: countryCode,
		}

		e.trafficData = append(e.trafficData, entry)

		// Limit entries
		if len(e.trafficData) >= 1000 {
			break
		}
	}

	if err := iter.Err(); err != nil {
		system.Warn("Error iterating ip_stats map: %v", err)
	}
}

// Disable stops eBPF monitoring
func (e *EBPFService) Disable() {
	e.mu.Lock()
	defer e.mu.Unlock()

	if !e.isRunning {
		return
	}

	e.enabled = false
	e.isRunning = false
	close(e.stopChan)

	// Detach eBPF program if loaded
	e.detachEBPF()
}

func (e *EBPFService) detachEBPF() {
	if e.link != nil {
		e.link.Close()
		e.link = nil
		system.Info("eBPF XDP program detached")
	}

	if e.objs != nil {
		if objs, ok := e.objs.(*xdpObjects); ok {
			objs.Close()
		}
		e.objs = nil
	}
}

// collectTrafficSimulation simulates traffic collection (fallback for non-Linux)
func (e *EBPFService) collectTrafficSimulation() {
	ticker := time.NewTicker(2 * time.Second)
	defer ticker.Stop()

	countries := []string{"KR", "US", "CN", "JP", "DE", "RU", "BR", "GB", "CA", "AU"}

	for {
		select {
		case <-e.stopChan:
			return
		case <-ticker.C:
			numEntries := 5 + (time.Now().Unix() % 10)

			e.mu.Lock()
			for i := int64(0); i < numEntries; i++ {
				ip := fmt.Sprintf("%d.%d.%d.%d",
					1+(time.Now().Unix()+i)%254,
					(time.Now().Unix()+i*2)%256,
					(time.Now().Unix()+i*3)%256,
					1+(time.Now().Unix()+i*4)%254)

				countryCode := "XX"
				if e.geoIPService != nil {
					countryCode = e.geoIPService.GetCountryCode(ip)
				} else {
					countryCode = countries[i%int64(len(countries))]
				}

				entry := TrafficEntry{
					SourceIP:    ip,
					DestPort:    []int{2302, 2303, 2304, 27016, 17777}[i%5],
					Protocol:    "UDP",
					PacketCount: int(100 + (time.Now().Unix()+i)%900),
					ByteCount:   int64(1000 + (time.Now().Unix()+i*100)%99000),
					Timestamp:   time.Now(),
					Blocked:     (time.Now().Unix()+i)%10 == 0,
					CountryCode: countryCode,
				}
				e.trafficData = append(e.trafficData, entry)
			}

			if len(e.trafficData) > 1000 {
				e.trafficData = e.trafficData[len(e.trafficData)-1000:]
			}
			e.mu.Unlock()
		}
	}
}

// GetTrafficData returns current traffic data
func (e *EBPFService) GetTrafficData() []TrafficEntry {
	e.mu.RLock()
	defer e.mu.RUnlock()

	data := make([]TrafficEntry, len(e.trafficData))
	copy(data, e.trafficData)
	return data
}

// GetStats returns aggregated statistics
func (e *EBPFService) GetStats() map[string]interface{} {
	e.mu.RLock()
	defer e.mu.RUnlock()

	totalPackets := 0
	totalBlocked := 0
	countryMap := make(map[string]int)

	for _, entry := range e.trafficData {
		totalPackets += entry.PacketCount
		if entry.Blocked {
			totalBlocked++
		}
		countryMap[entry.CountryCode]++
	}

	return map[string]interface{}{
		"total_packets":   totalPackets,
		"total_entries":   len(e.trafficData),
		"blocked_entries": totalBlocked,
		"countries":       countryMap,
		"enabled":         e.enabled,
		"mode":            e.getMode(),
	}
}

func (e *EBPFService) getMode() string {
	if e.objs != nil {
		return "eBPF/XDP"
	}
	return "Simulation"
}

// IsEnabled returns whether eBPF is currently enabled
func (e *EBPFService) IsEnabled() bool {
	e.mu.RLock()
	defer e.mu.RUnlock()
	return e.enabled
}

// Helper functions - Corrected for Endianness

// ipToUint32 converts IP to uint32 in Big Endian (Network Byte Order)
func ipToUint32(ip net.IP) uint32 {
	ip = ip.To4()
	if ip == nil {
		return 0
	}
	return binary.BigEndian.Uint32(ip)
}

// uint32ToIP converts Big Endian uint32 back to IP
func uint32ToIP(n uint32) net.IP {
	ip := make(net.IP, 4)
	binary.BigEndian.PutUint32(ip, n)
	return ip
}

// UpdateBlockedIPs updates the blocked_ips BPF map
func (e *EBPFService) UpdateBlockedIPs(ips []string) error {
	if e.objs == nil {
		return nil // Not in eBPF mode
	}

	objs, ok := e.objs.(*xdpObjects)
	if !ok {
		return nil
	}

	for _, ipStr := range ips {
		ip := net.ParseIP(ipStr)
		if ip == nil {
			continue
		}

		// Use BigEndian
		ipUint := ipToUint32(ip)
		blocked := uint32(1)

		if err := objs.BlockedIps.Put(ipUint, blocked); err != nil {
			system.Warn("Failed to add blocked IP %s: %v", ipStr, err)
		}
	}

	system.Info("Updated %d blocked IPs in eBPF map", len(ips))
	return nil
}

// UpdateGeoAllowed updates the geo_allowed BPF map
func (e *EBPFService) UpdateGeoAllowed(allowedCountries []string) error {
	if e.objs == nil {
		return nil // Not in eBPF mode
	}

	// Repopulate with new countries (simplified clear approach)
	e.populateGeoIPMap()

	system.Info("Updated geo-allowed countries: %v", allowedCountries)
	return nil
}
