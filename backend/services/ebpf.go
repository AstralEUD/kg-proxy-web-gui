package services

import (
	"encoding/binary"
	"fmt"
	"net"
	"runtime"
	"sync"
	"time"

	"kg-proxy-web-gui/backend/system"

	"github.com/cilium/ebpf/link"
)

//go:generate bpf2go -cc clang -cflags "-O2 -g -Wall -Werror" xdp ../ebpf/xdp_filter.c -- -I/usr/include/x86_64-linux-gnu

// TrafficEntry represents a single traffic record
type TrafficEntry struct {
	SourceIP    string
	DestPort    int
	Protocol    string
	PacketCount int
	ByteCount   int64
	Timestamp   time.Time
	Blocked     bool
	CountryCode string
}

// PacketStats matches the C struct
type PacketStats struct {
	Packets  uint64
	Bytes    uint64
	LastSeen uint64
	Blocked  uint32
	_        uint32 // padding
}

// EBPFService manages eBPF/XDP traffic monitoring
type EBPFService struct {
	enabled     bool
	trafficData []TrafficEntry
	mu          sync.RWMutex
	stopChan    chan struct{}
	isRunning   bool

	// Real eBPF objects - using interface{} to avoid build errors when generated files are missing
	// In production (Linux build), this will hold *xdpObjects
	objs         interface{}
	link         link.Link
	geoIPService *GeoIPService

	// Interface name
	ifaceName string

	// Boot time for timestamp conversion
	bootTime time.Time
}

func NewEBPFService() *EBPFService {
	// Calculate boot time to handle monotonic timestamps
	// We use the SysInfoService or just standard uptime

	now := time.Now()
	boot := now // Default fallback

	if runtime.GOOS == "linux" {
		// Read /proc/uptime
		// simplified for now, assuming uptime is roughly correct
		// If we can't read it, we use Now (last seen will be relative to now, which is wrong but safe)
		// We'll rely on the fact that value.LastSeen is monotonic ns
		// We need relative offset: Now - MonotonicNow
		// But getting MonotonicNow in Go is internal.
		// Approximating:
		// timestamp = bootTime + monotonic
	}

	// Better: Use a helper
	boot = GetBootTime()

	return &EBPFService{
		enabled:     false,
		trafficData: make([]TrafficEntry, 0),
		stopChan:    make(chan struct{}),
		ifaceName:   "eth0",
		bootTime:    boot,
	}
}

// SetGeoIPService sets the GeoIP service for country lookups
func (e *EBPFService) SetGeoIPService(geoip *GeoIPService) {
	e.geoIPService = geoip
}

// Enable starts eBPF monitoring
func (e *EBPFService) Enable() error {
	e.mu.Lock()
	defer e.mu.Unlock()

	if e.isRunning {
		return nil
	}

	// Only try real eBPF on Linux
	if runtime.GOOS != "linux" {
		return fmt.Errorf("eBPF is only supported on Linux")
	}

	// Try to load real eBPF program
	if err := e.loadEBPFProgram(); err != nil {
		return fmt.Errorf("failed to load eBPF program: %w", err)
	}

	e.enabled = true
	e.isRunning = true
	e.stopChan = make(chan struct{})

	// Start real traffic collection from eBPF maps
	go e.collectTrafficFromEBPF()

	system.Info("eBPF XDP filter loaded and attached to %s", e.ifaceName)
	return nil
}

// loadEBPFProgram loads the compiled eBPF program
func (e *EBPFService) loadEBPFProgram() error {
	// Detect network interface
	iface, err := e.detectInterface()
	if err != nil {
		return fmt.Errorf("failed to detect network interface: %w", err)
	}
	e.ifaceName = iface.Name

	// Load pre-compiled eBPF objects
	// Note: xdpObjects is generated by bpf2go.
	// We use struct literal assuming the generated file is present in build env
	objs := &xdpObjects{}
	if err := loadXdpObjects(objs, nil); err != nil {
		return fmt.Errorf("loading eBPF objects: %w", err)
	}
	e.objs = objs

	// Attach XDP program to interface
	l, err := link.AttachXDP(link.XDPOptions{
		Program:   objs.XdpTrafficFilter,
		Interface: iface.Index,
	})
	if err != nil {
		objs.Close()
		return fmt.Errorf("attaching XDP program: %w", err)
	}
	e.link = l

	// Initialize BPF maps with GeoIP data
	if e.geoIPService != nil {
		e.populateGeoIPMap()
	}

	return nil
}

// detectInterface finds the primary network interface
func (e *EBPFService) detectInterface() (*net.Interface, error) {
	// Try common interface names
	names := []string{"eth0", "ens3", "ens5", "enp0s3", "wlan0"}

	for _, name := range names {
		iface, err := net.InterfaceByName(name)
		if err == nil && iface.Flags&net.FlagUp != 0 {
			return iface, nil
		}
	}

	// Fallback: find first non-loopback interface
	ifaces, err := net.Interfaces()
	if err != nil {
		return nil, err
	}

	for _, iface := range ifaces {
		if iface.Flags&net.FlagUp != 0 && iface.Flags&net.FlagLoopback == 0 {
			return &iface, nil
		}
	}

	return nil, fmt.Errorf("no suitable network interface found")
}

// populateGeoIPMap populates the geo_allowed BPF map
func (e *EBPFService) populateGeoIPMap() error {
	if e.objs == nil || e.geoIPService == nil {
		return nil
	}

	objs, ok := e.objs.(*xdpObjects)
	if !ok {
		return nil
	}

	system.Info("Populating GeoIP BPF map...")
	count := 0

	e.geoIPService.mu.RLock()
	defer e.geoIPService.mu.RUnlock()

	for country, ranges := range e.geoIPService.countryRanges {
		countryCode := uint32(country[0])<<8 | uint32(country[1])

		for _, ipRange := range ranges {
			// For each IP in the range, add to map
			ip := ipRange.IP.To4()
			if ip == nil {
				continue
			}

			// Use BigEndian to match network byte order in BPF
			ipUint := binary.BigEndian.Uint32(ip)

			if err := objs.GeoAllowed.Put(ipUint, countryCode); err != nil {
				system.Warn("Failed to add IP to geo_allowed map: %v", err)
				continue
			}
			count++

			// Limit to prevent map overflow
			if count >= 100000 {
				system.Warn("GeoIP map limit reached, some IPs not added")
				return nil
			}
		}
	}

	system.Info("Populated GeoIP map with %d entries", count)
	return nil
}

// collectTrafficFromEBPF reads real data from eBPF maps
func (e *EBPFService) collectTrafficFromEBPF() {
	ticker := time.NewTicker(2 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-e.stopChan:
			return
		case <-ticker.C:
			e.readEBPFMaps()
		}
	}
}

// readEBPFMaps reads statistics from eBPF maps
func (e *EBPFService) readEBPFMaps() {
	if e.objs == nil {
		return
	}

	objs, ok := e.objs.(*xdpObjects)
	if !ok {
		return
	}

	e.mu.Lock()
	defer e.mu.Unlock()

	// Clear old data
	e.trafficData = make([]TrafficEntry, 0)

	// Iterate over the map
	// Use [4]byte for key to parse IP correctly regardless of host endianness
	var key [4]byte
	var value PacketStats

	// We need to lock while iterating if we were modifying, but here we just read.
	// BPF map iteration is generally safe.
	iter := objs.IpStats.Iterate()
	for iter.Next(&key, &value) {
		// Convert key bytes directly to IP
		ip := net.IPv4(key[0], key[1], key[2], key[3])

		// Get country code
		countryCode := "XX"
		if e.geoIPService != nil {
			countryCode = e.geoIPService.GetCountryCode(ip.String())
		}

		// Create entry
		entry := TrafficEntry{
			SourceIP:    ip.String(),
			DestPort:    0, // Not tracked in current eBPF program
			Protocol:    "IP",
			PacketCount: int(value.Packets),
			ByteCount:   int64(value.Bytes),
			Timestamp:   e.bootTime.Add(time.Duration(value.LastSeen)), // Correct monotonic -> wall time
			Blocked:     value.Blocked == 1,
			CountryCode: countryCode,
		}

		e.trafficData = append(e.trafficData, entry)

		// Limit entries
		if len(e.trafficData) >= 1000 {
			break
		}
	}

	if err := iter.Err(); err != nil {
		system.Warn("Error iterating ip_stats map: %v", err)
	}
}

// Disable stops eBPF monitoring
func (e *EBPFService) Disable() {
	e.mu.Lock()
	defer e.mu.Unlock()

	if !e.isRunning {
		return
	}

	e.enabled = false
	e.isRunning = false
	close(e.stopChan)

	// Detach eBPF program if loaded
	e.detachEBPF()
}

func (e *EBPFService) detachEBPF() {
	if e.link != nil {
		e.link.Close()
		e.link = nil
		system.Info("eBPF XDP program detached")
	}

	if e.objs != nil {
		if objs, ok := e.objs.(*xdpObjects); ok {
			objs.Close()
		}
		e.objs = nil
	}
}

// GetTrafficData returns current traffic data
func (e *EBPFService) GetTrafficData() []TrafficEntry {
	e.mu.RLock()
	defer e.mu.RUnlock()

	data := make([]TrafficEntry, len(e.trafficData))
	copy(data, e.trafficData)
	return data
}

// GetStats returns aggregated statistics
func (e *EBPFService) GetStats() map[string]interface{} {
	e.mu.RLock()
	defer e.mu.RUnlock()

	totalPackets := 0
	totalBlocked := 0
	countryMap := make(map[string]int)

	for _, entry := range e.trafficData {
		totalPackets += entry.PacketCount
		if entry.Blocked {
			totalBlocked++
		}
		countryMap[entry.CountryCode]++
	}

	return map[string]interface{}{
		"total_packets":   totalPackets,
		"total_entries":   len(e.trafficData),
		"blocked_entries": totalBlocked,
		"countries":       countryMap,
		"enabled":         e.enabled,
		"mode":            "eBPF/XDP",
	}
}

// IsEnabled returns whether eBPF is currently enabled
func (e *EBPFService) IsEnabled() bool {
	e.mu.RLock()
	defer e.mu.RUnlock()
	return e.enabled
}

// Helper functions - Corrected for Endianness

// ipToUint32 converts IP to uint32 in Big Endian (Network Byte Order)
func ipToUint32(ip net.IP) uint32 {
	ip = ip.To4()
	if ip == nil {
		return 0
	}
	return binary.BigEndian.Uint32(ip)
}

// uint32ToIP converts Big Endian uint32 back to IP
func uint32ToIP(n uint32) net.IP {
	ip := make(net.IP, 4)
	binary.BigEndian.PutUint32(ip, n)
	return ip
}

// UpdateBlockedIPs updates the blocked_ips BPF map
func (e *EBPFService) UpdateBlockedIPs(ips []string) error {
	if e.objs == nil {
		return nil // Not in eBPF mode
	}

	objs, ok := e.objs.(*xdpObjects)
	if !ok {
		return nil
	}

	for _, ipStr := range ips {
		ip := net.ParseIP(ipStr)
		if ip == nil {
			continue
		}

		// Use BigEndian
		ipUint := ipToUint32(ip)
		blocked := uint32(1)

		if err := objs.BlockedIps.Put(ipUint, blocked); err != nil {
			system.Warn("Failed to add blocked IP %s: %v", ipStr, err)
		}
	}

	system.Info("Updated %d blocked IPs in eBPF map", len(ips))
	return nil
}

// UpdateGeoAllowed updates the geo_allowed BPF map
func (e *EBPFService) UpdateGeoAllowed(allowedCountries []string) error {
	if e.objs == nil {
		return nil // Not in eBPF mode
	}

	// Repopulate with new countries (simplified clear approach)
	e.populateGeoIPMap()

	system.Info("Updated geo-allowed countries: %v", allowedCountries)
	return nil
}
